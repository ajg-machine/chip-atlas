<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
        
        <title>ChIP Atlas</title>
        
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&family=Roboto+Flex:opsz,wght,XOPQ,XTRA,YOPQ,YTDE,YTFI,YTLC,YTUC@8..144,100..1000,96,468,79,-203,738,514,712&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible+Mono:ital,wght@0,200..800;1,200..800&family=Atkinson+Hyperlegible+Next:ital,wght@0,200..800;1,200..800&display=swap" rel="stylesheet">

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
        
        <script async src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>

        <style>
            html { -webkit-text-size-adjust: 100%; }
            body { padding: 0; margin: 0; }
            
            :root {
                --font-size: 13px;
                --font-family: "Roboto Flex", system-ui, sans-serif;
                --font-family-mono: "Roboto Mono", ui-monospace, monospace;
                --font-family-condensed: "Roboto Condensed", system-ui, sans-serif;
                --accent-color: oklch(58.8% 0.158 241.966);
                --desaturated-color: oklch(70.7% 0.022 261.325);
                --highly-desaturated-color: oklch(92.8% 0.006 264.531);
                --desaturated-accent-color: oklch(70.711% 0.09331 247.43);
            }

            .material-symbols-outlined {
                font-variation-settings:
                'FILL' 0,
                'wght' 400,
                'GRAD' 0,
                'opsz' 24
            }

            main {
                font-family: var(--font-family);
                font-size: var(--font-size);
            }

            a {
                text-decoration: none;
                cursor: pointer;
            }
            a:not(.only-colored-on-hover) {
                color: var(--accent-color);
            }
            a:hover {
                color: var(--accent-color);
            }
            a:hover:not(.no-underline) {
                text-decoration: underline;
            }
            a.desaturated-color {
                color: var(--desaturated-accent-color);
            }

            .markdown h3 {
                font-size: var(--font-size);
            }
            .markdown ul, .markdown ol {
                padding-inline-start: 1.5em;
            }
            .markdown h3, .markdown p, .markdown ul, .markdown ol {
                margin-block-start: 5px;
                margin-block-end: 5px;
            }
            .markdown h3:not(:first-child) {
                margin-block-start: 10px;
            }
            .markdown > :first-child, .markdown > :last-child {
                margin-block-start: 0px;
                margin-block-end: 0px;
            }

            .appear-smoothly {
                animation: appearSmoothly 0.4s ease;
            }
            @keyframes appearSmoothly {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            .checkbox {
                cursor: pointer;
                display: flex;
                align-items: center;
            }
            .checkbox:hover {
                color: var(--accent-color);
            }
            .checkbox::before {
                color: var(--accent-color);
                padding-right: 3px;
            }
            .checkbox[data-checked="true"]::before {
                font-family: "Material Symbols Outlined";
                content: "radio_button_checked";
                font-size: 95%;
            }
            .checkbox:not([data-checked="true"])::before {
                font-family: "Material Symbols Outlined";
                content: "radio_button_unchecked";
                font-size: 95%;
            }

            .symbol-left, .symbol-right {
                cursor: pointer;
                display: flex;
                align-items: center;
            }
            .symbol-left::before {
                content: attr(data-symbol);
                font-family: "Material Symbols Outlined";
                padding-right: 3px;
                font-size: 95%;
            }
            .symbol-right::after {
                content: attr(data-symbol);
                font-family: "Material Symbols Outlined";
                padding-left: 3px;
                font-size: 95%;
            }
            .symbol-left.symbol-colored::before, .symbol-right.symbol-colored::after {
                color: var(--accent-color);
            }

            #explorer {
                display: grid;
                grid-template-columns: 600px 1fr;
                height: 100dvh;
            }

            #samples-list-wrapper {
                overflow-y: auto;
                overflow-x: auto;
                padding: 20px;
            }
            #samples-list {
                display: grid;
                grid-template-columns: repeat(4, max-content);
                column-gap: 20px;
                row-gap: 10px;
            }
            #samples-list > div {
                display: contents;
            }
            #samples-list > div:not(:nth-child(1)):hover {
                color: var(--accent-color);
            }
            #samples-list > div:nth-child(1) {
                font-weight: bold;
            }
            #samples-list > div:nth-child(1) > div {
                display: flex;
                flex-direction: row;
                align-items: center;
                column-gap: 5px;
                
                position: sticky;
                top: 0;
                background: white;
                z-index: 2;
                padding-bottom: 5px;
            }
            #samples-list > div:nth-child(1) > div::before {
                content: "";
                position: absolute;
                top: -20px;
                left: 0;
                width: 100%;
                height: 20px;
                background: white;
            }
            #samples-list > div > div {
                min-width: 40px;
                max-width: 280px;
            }
            #samples-list > div:not(div:nth-child(1)) > div > div:nth-child(2) {
                font-size: 10px;
                color: var(--desaturated-color);
            }
            #samples-list > div:nth-child(1) > div,
            #samples-list > div > div:nth-child(1) {
                cursor: pointer;
            }

            #panel {
                border-left: 1px solid black;
                position: sticky;
                top: 0px;
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr;
                height: 100dvh;
            }
            #panel > div:nth-child(1) {
                grid-area: 1 / 1 / 2 / 3;
            }
            #panel > div:nth-child(2) {
                grid-area: 2 / 1 / 3 / 2;
            }
            #panel > div:nth-child(3) {
                grid-area: 2 / 2 / 3 / 3;
            }

            #controls {
                padding-bottom: 10px;
                padding-bottom: 20px;
                border-bottom: 1px solid black;
                padding: 20px;
                display: flex;
                flex-direction: column;
                row-gap: 10px;
            }

            #controls > div:not(#search-control) {
                display: flex;
                flex-direction: row;
                column-gap: 10px;
            }

            #search-control {
                display: grid;
                grid-template-columns: max-content auto max-content;
                column-gap: 10px;
                border-bottom: 1px solid var(--highly-desaturated-color);
                padding-bottom: 3px;
            }

            #search-control:hover,
            #search-control:focus-within {
                border-bottom: 1px solid var(--accent-color);
            }

            #search-control #search {
                outline: none;
            }

            #listing {
                overflow-y: auto;
                display: flex;
                flex-direction: column;
            }
            #listing > div:nth-child(1) {
                display: flex;
                flex-direction: row;
                gap: 15px;
                padding: 20px;
                border-bottom: 1px solid black;
                position: sticky;
                top: 0;
                background: white;
            }
            #listing > div:nth-child(2) {
                display: flex;
                flex-direction: column;
                gap: 15px;
                word-break: break-word;
                padding: 20px;
            }
            #listing > div:nth-child(2) > div {
                display: flex;
                flex-direction: column;
                gap: 3px;
            }
            #listing > div:nth-child(2) > div :empty {
                display: none;
            }
            #listing > div:nth-child(2) > div > :nth-child(1) > :nth-child(1) {
                font-weight: bold;
                margin-right: 10px;
            }
            #listing > div:nth-child(2) > div > :nth-child(2) {
                font-size: 10px;
                color: var(--desaturated-color);
            }

            #full-sample {
                display: flex;
                flex-direction: column;
                border-left: 1px solid black;
                overflow-y: auto;
            }
            #full-sample > .control {
                display: flex;
                flex-direction: row;
                gap: 15px;
                padding: 20px;
                border-bottom: 1px solid black;
                position: sticky;
                top: 0;
                background: white;
            }
            #full-sample > .sections {
                display: flex;
                flex-direction: column;
                gap: 15px;
                padding: 20px;
            }
            #full-sample .section {
                display: flex;
                flex-direction: column;
                gap: 5px;
            }
            #full-sample .section:empty {
                display: none;
            }
            #full-sample .section:not(:first-child)::before {
                content: "";
                border-bottom: 1px solid var(--highly-desaturated-color);
                margin-bottom: 10px;
            }

            #full-sample .key-value-pair > div:first-child {
                display: inline;
                font-weight: bold;
                margin-right: 10px;
            }
            #full-sample .key-value-pair > div:nth-child(2) {
                display: inline;
            }
            #full-sample .key-value-pair > div:nth-child(2) > :not(:last-child) {
                margin-right: 10px;
            }
            #full-sample .key-value-pair > div:empty {
                display: none;
            }


        </style>
    </head>
    <body>
        <main>

            <div id="explorer">
                <div id="samples-list-wrapper">
                    <div id="samples-list"></div>
                </div>
                <div id="panel">
                    <div id="controls">
                        <div>
                            <div>Display:</div>
                            <div class="checkbox" id="toggle-summaries" onclick="databaseControl('toggle-summaries')" data-checked="true">Summaries</div>
                        </div>
                        <div id="genome-control">
                            <div>Genome:</div>
                        </div>
                        <div id="search-fields-control">
                            <div>Search in:</div>
                            <div class="checkbox" data-checked="true" data-indexes="0,1,2">IDs</div>
                            <div class="checkbox" data-checked="true" data-indexes="5">Target</div>
                            <div class="checkbox" data-checked="true" data-indexes="4">Cell</div>
                            <div class="checkbox" data-checked="true" data-indexes="10,11">Aliases</div>
                            <div class="checkbox" data-indexes="6">Date</div>
                            <div class="checkbox" data-indexes="7">Title</div>
                            <div class="checkbox" data-indexes="9">Attributes</div>
                        </div>
                        <div id="search-control">
                            <div>Search:</div>
                            <div id="search" contenteditable="plaintext-only" oninput="searchSamples()"></div>
                            <div id="search-count"></div>
                        </div>
                    </div>
                    <div id="listing"></div>
                    <div id="full-sample"></div>
                </div>
            </div>



        </main>
        <script>
"use strict";

let BASE_URL = "https://raw.githubusercontent.com/ajg-machine/chip-atlas/main";
let STATE = {
    genome: {selected: "mm10", available: null},
    database: {},
    targetsSummaries: {},
    cellsSummaries: {},
    targetsAliasesInserted: {},
    cellsAliasesInserted: {},
    display: {
        summaries: true,
        sampleCount: 500,
        listingCount: 500,
        listing: "targets",
    },
    fullInfo: {back: [], forward: []},
    sort: {by: 6, reverse: true},
};


function formatNumber(number, {notation="full", precision=null, thousands=null}={}) {
    let suffix = "";
    if (notation === "si") {
        if (number !== 0) {
            let absNumber = Math.abs(number);
            let exponent = Math.floor(Math.log10(absNumber) / 3);
            let scaled;
            if (exponent >= 0) {
                let suffixes = ["", "k", "M", "G", "T", "P", "E"];
                let index = Math.min(exponent, suffixes.length - 1);
                scaled = absNumber / Math.pow(1000, index);
                suffix = ` ${suffixes[index]}`;
            } else {
                let suffixes = ["", "m", "Î¼", "n", "p"];
                let index = Math.min(-exponent, suffixes.length - 1);
                scaled = absNumber * Math.pow(1000, index);
                suffix = ` ${suffixes[index]}`;
            }
            number = ((number < 0) ? -1 : 1) * scaled;
        }
    } else if (notation === "scientific" || notation === "sci") {
        if (number !== 0) {
            let exponent = Math.floor(Math.log10(Math.abs(number)));
            number /= Math.pow(10, exponent);
            suffix = `e${exponent}`;
        }
    } else if (notation !== "full") {
        throw new Error(`unknown notation: ${notation}`);
    }
    if (precision !== null) {
        const rounded = Math.round(Number(number) / precision) * precision;
        const decimals = (precision >= 1) ? 0 : Math.max(0, Math.ceil(-Math.log10(precision)));
        number = rounded.toFixed(decimals);
    } else {
        number = number.toString();
    }
    if (thousands !== null && !/[eE]/.test(number)) {
        let neg = number.startsWith("-") ? "-" : "";
        if (neg) number = number.slice(1);
        let parts = number.split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, thousands);
        number = neg + parts.join(".");
    }
    return `${number}${suffix}`;
}


async function fetchUrl(url, {decompress=null, ...options}={}) {
    let response = await fetch(url, options);
    if (!response.ok) throw new Error(response);
    if (decompress) {
        let decompressionStream = new DecompressionStream(decompress);
        let decompressedStream = response.body.pipeThrough(decompressionStream);
        response = new Response(decompressedStream);
    }
    return response;
}


async function databaseControl(key) {
    if (key === "toggle-summaries") {
        STATE.display.summaries = !STATE.display.summaries;
        document.querySelector("#toggle-summaries").dataset.checked = STATE.display.summaries ? "true" : "false";
        await searchSamples();
    } else {
        throw new Error(`Unknown database control key: ${key}`);
    }
}


function getEntryTargetName(name) {
    return name.toLowerCase().match(/^([^(]*).*$/)[1].replace(/[^\w()]+/g, "");
}


async function getTargetsSummaries({genome}={}) {
    if (STATE.targetsSummaries[genome] != null) return STATE.targetsSummaries[genome];
    STATE.targetsSummaries[genome] = new Promise(async (resolve, reject) => {
        try {
            let url = `${BASE_URL}/summaries/targets/${genome}.json.gz`;
            let data = {};
            try {
                let response = await fetchUrl(url, {decompress: "gzip"});
                data = await response.json();
            } catch (e) {
                console.error(`No targets summaries for genome ${genome}`);
            }
            let targetsSummaries = new Map();
            for (let [name, entryData] of Object.entries(data)) {
                let minimalName = getEntryTargetName(name);
                entryData.name = name;
                entryData.minimalName = minimalName;
                entryData.aliases = entryData.aliases
                    .filter(alias => getEntryTargetName(alias) !== minimalName);
                targetsSummaries.set(minimalName, entryData);
            }
            if (!STATE.targetsAliasesInserted[genome]) {
                let database = await getDatabase({genome});
                for (let entry of database) {
                    let minimalName = getEntryTargetName(entry[5][0]);
                    let summary = targetsSummaries.get(minimalName);
                    if (!summary) continue;
                    let aliases = [summary.name, summary.full_name, ...summary.aliases]
                        .map(getEntryTargetName);
                    entry[10][1] = (entry[10][1] ? entry[10][1] + " " : "") + aliases.join(" ");            
                }
                STATE.targetsAliasesInserted[genome] = true;
            }
            resolve(targetsSummaries);
        } catch (e) {
            reject(e);
        }
    });
    return STATE.targetsSummaries[genome];
}


async function getCellsSummaries({genome}={}) {
    if (STATE.cellsSummaries[genome] != null) return STATE.cellsSummaries[genome];
    STATE.cellsSummaries[genome] = new Promise(async (resolve, reject) => {
        try {
            let url = `${BASE_URL}/summaries/cells/${genome}.json.gz`;
            let data = {};
            try {
                let response = await fetchUrl(url, {decompress: "gzip"});
                data = await response.json();
            } catch (e) {
                console.error(`No cells summaries for genome ${genome}`);
            }
            let cellsSummaries = new Map();
            for (let [name, entryData] of Object.entries(data)) {
                let minimalName = getEntryTargetName(name);
                entryData.name = name;
                entryData.minimalName = minimalName;
                entryData.aliases = entryData.aliases
                    .filter(alias => getEntryTargetName(alias) !== minimalName);
                cellsSummaries.set(minimalName, entryData);
            }
            if (!STATE.cellsAliasesInserted[genome]) {
                let database = await getDatabase({genome});
                for (let entry of database) {
                    let minimalName = getEntryTargetName(entry[4][0]);
                    let summary = cellsSummaries.get(minimalName);
                    if (!summary) continue;
                    let aliases = [summary.name, summary.full_name, ...summary.aliases]
                        .map(getEntryTargetName);
                    entry[11][1] = (entry[11][1] ? entry[11][1] + " " : "") + aliases.join(" ");            
                }
                STATE.cellsAliasesInserted[genome] = true;
            }
            resolve(cellsSummaries);
        } catch (e) {
            reject(e);
        }
    });
    return STATE.cellsSummaries[genome];
}


async function getAvailableGenomes() {
    if (STATE.genome.available) return STATE.genome.available;
    STATE.genome.available = new Promise(async (resolve, reject) => {
        try {
            let url = `${BASE_URL}/database/genomes.json`;
            let response = await fetchUrl(url);
            let data = await response.json();

            let genomeControl = document.querySelector("#genome-control");
            genomeControl.querySelectorAll(".checkbox").forEach(e => e.remove());
            for (let choice of Object.keys(data).toSorted()) {
                let div = genomeControl.appendChild(document.createElement("div"));
                div.textContent = choice;
                div.classList.add("checkbox");
                div.dataset.checked = (choice === STATE.genome.selected ? "true" : "false");
                div.onclick = async () => {
                    if (div.dataset.checked === "true") return;
                    genomeControl.querySelectorAll(".checkbox").forEach(e => e.dataset.checked = "false");
                    div.dataset.checked = "true";
                    STATE.genome.selected = choice;
                    await searchSamples();
                };
            }
            resolve(data);
        } catch (e) {
            reject(e);
        }
    });
    return STATE.genome.available;
}


async function getDatabase({genome}={}) {
    genome = genome.toLowerCase();
    if (STATE.database[genome]) return STATE.database[genome];
    STATE.database[genome] = new Promise(async (resolve, reject) => {
        try {
            let file = `${genome}.full.tsv.gz`;
            let url = `${BASE_URL}/database/genomes/${file}`;
            let response = await fetchUrl(url, {decompress: "gzip"});
            let data = await response.text();
            // 12 -> 2 others columns may be added at the end for targets and cells aliases
            data = data
                .trimEnd().split("\n")
                .map(line => line.split("\t"))
                .map(line => line.length < 12 ? line.concat(Array(12 - line.length).fill("")) : line)
                .map(line => line.map((entry, index) => {
                    if (index === 9) {
                        entry = [entry, entry
                            .toLowerCase()
                            .split(";")
                            .map(x => x.split("=").map(y => y.replace(/[^\w()]+/g, "")))
                            .flat()
                            .join(" ")
                        ];
                    } else {
                        entry = [entry, entry.toLowerCase().replace(/[^\w()]+/g, "")];
                    }
                    return entry;
                }));
                resolve(data);
        } catch (e) {
            reject(e);
        }
    });
    return STATE.database[genome];
}


async function updateSamplesList({genome, database}={}) {
    let sampleCount = formatNumber(database.length, {thousands: ","})
    document.getElementById("search-count").textContent = `${sampleCount} samples`;
    let samplesDiv = document.getElementById("samples-list");
    samplesDiv.textContent = "";

    let rowDiv = samplesDiv.appendChild(document.createElement("div"));
    for (let [title, sortIndex] of [["Date", 6], ["IDs", 0], ["Target", 5], ["Cell", 4]]) {
        let div = rowDiv.appendChild(document.createElement("div"));
        let titleDiv = div.appendChild(document.createElement("div"));
        div.appendChild(document.createElement("div"));
        titleDiv.textContent = title;
        div.dataset.sortIndex = sortIndex;
        if (STATE.sort.by === Number(div.dataset.sortIndex)) {
            div.children[1].textContent = STATE.sort.reverse ? "keyboard_arrow_down" : "keyboard_arrow_up";
            div.children[1].style.fontFamily = "Material Symbols Outlined";
            div.children[1].style.fontSize = "95%";
        }
        div.onclick = () => {
            if (STATE.sort.by === Number(div.dataset.sortIndex)) {
                STATE.sort.reverse = !STATE.sort.reverse;
            } else {
                STATE.sort.by = Number(div.dataset.sortIndex);
            }
            searchSamples();
        };
    }

    let makeItemsDivs = (rowDiv) => {
        let itemsDivs = [];
        for (let i = 0; i < 4; i++) {
            let itemDiv = rowDiv.appendChild(document.createElement("div"));
            let mainItemDiv = itemDiv.appendChild(document.createElement("div"));
            let subItemDiv = itemDiv.appendChild(document.createElement("div"));
            itemsDivs.push([mainItemDiv, subItemDiv]);
        }
        return itemsDivs;
    };

    for (let [index, sample] of database.entries()) {
        rowDiv = samplesDiv.appendChild(document.createElement("div"));
        let itemDivs = makeItemsDivs(rowDiv);

        
        if (index >= STATE.display.sampleCount) {
            let moreCount = formatNumber(database.length - STATE.display.sampleCount, {thousands: ","})
            itemDivs[3][0].textContent = `[ + ${moreCount} more ]`;
            break;
        }

        itemDivs[0][0].textContent = sample[6][0];
        itemDivs[0][1].textContent = "+ Expand";
        itemDivs[0][1].style.color = "var(--desaturated-accent-color)";
        itemDivs[0][0].onclick = () => showFullSample({genome, key: sample[2][0]});
        itemDivs[0][1].onclick = () => showFullSample({genome, key: sample[2][0]});
        itemDivs[1][0].textContent = sample[0][0];
        itemDivs[1][1].textContent = sample[2][0];
        itemDivs[2][0].textContent = sample[5][0].match(/^([^(]*).*$/)[1];
        itemDivs[2][1].textContent = (sample[5][0].match(/^[^(]*\(([^(]*)\)$/) || ["", ""])[1];
        if (itemDivs[2][0].textContent.match(/^RNA polymerase ([IVX]+)$/i)) {
            itemDivs[2][0].textContent = "Pol " + itemDivs[2][0].textContent.match(/^RNA polymerase ([IVX]+)$/i)[1];
            itemDivs[2][1].textContent = "RNA polymerase";
        } else if (itemDivs[2][0].textContent === "Input control") {
            itemDivs[2][0].textContent = "Input"
            itemDivs[2][1].textContent = "Control";
        } else if (itemDivs[2][0].textContent.match(/^([^-]+)-Seq$/i)) {
            itemDivs[2][0].textContent = itemDivs[2][0].textContent.match(/^([^-]+)-Seq$/i)[1];
            itemDivs[2][1].textContent = "Seq";
        }
        itemDivs[3][0].textContent = sample[4][0].match(/^([^(]*).*$/)[1];
        itemDivs[3][1].textContent = (sample[4][0].match(/^[^(]*\(([^(]*)\)$/) || ["", ""])[1];



    }

}


async function searchSamples() {
    let genome = STATE.genome.selected;
    let database = getDatabase({genome});
    let targetsSummaries = getTargetsSummaries({genome});
    let cellsSummaries = getCellsSummaries({genome});
    database = await database;
    targetsSummaries = await targetsSummaries;
    cellsSummaries = await cellsSummaries;
    let queryString = document.querySelector("#search").textContent;
    let searchFieldsIndexes = Array.from(document.querySelectorAll("#search-fields-control > div[data-checked='true']"))
        .map(div => div.dataset.indexes.split(",").map(Number))
        .flat();
    
    // Parse query string into a tree structure
    let parseQuery = (str) => {
        str = str.trim();
        
        // Check if it's wrapped in parentheses with an operator
        let strMatch = str.match(/^\(\s*(and|or|xor|not):\s*(.+?)\s*\)$/i);
        if (strMatch) {
            let [operator, content] = [strMatch[1].toLowerCase(), strMatch[2]];
            return {type: operator, children: parseQueryList(content)};
        }
        
        // Check if it's wrapped in parentheses without an operator (default to AND)
        if (str.match(/^\(.+\)$/)) {
            let content = str.slice(1, -1).trim();
            return {type: "and", children: parseQueryList(content)};
        }
        
        // Check if multiple terms without parentheses (default to AND)
        let content = str.split(/\s+/);
        if (content.length > 1) {
            return parseQuery(`(and: ${content.join(" ")})`);
        }
        
        // Single term (no parentheses or operator)
        let normalized = str
            .toLowerCase()
            .replace(/[^\w()]+/g, "");
        
        // Handle pol1-9 to roman numerals - create OR with both versions
        if (normalized.match(/^pol([ivx\d]+)$/)) {
            let x = normalized.match(/^pol([ivx\d]+)$/)[1];
            let roman =
                x === "1" ? "i" : x === "2" ? "ii" :
                x === "3" ? "iii" : x === "4" ? "iv" :
                x === "5" ? "v" : x === "6" ? "vi" :
                x === "7" ? "vii" : x === "8" ? "viii" :
                x === "9" ? "ix" : x;
            let romanForm = `rnapolymerase${roman}`;
            return {
                type: "or",
                children: [
                    {type: "term", value: normalized},
                    {type: "term", value: romanForm}
                ]
            };
        }
        return {type: "term", value: normalized};
    };
    
    let parseQueryList = (str) => {
        let terms = [];
        let depth = 0;
        let current = "";
        for (let i = 0; i < str.length; i++) {
            let char = str[i];
            if (char === "(") {
                depth++;
                current += char;
            } else if (char === ")") {
                depth--;
                current += char;
            } else if (char === " " && depth === 0) {
                if (current.trim().length > 0) {
                    terms.push(parseQuery(current.trim()));
                    current = "";
                }
            } else {
                current += char;
            }
        }
        if (current.trim().length > 0) {
            terms.push(parseQuery(current.trim()));
        }
        return terms;
    };
    
    // Evaluate query tree against a sample
    let evaluateQuery = (query, sample) => {
        if (query.type === "term") {
            for (let fieldIndex of searchFieldsIndexes) {
                let field = sample[fieldIndex];
                if (field[1].includes(query.value)) {
                    return true;
                }
            }
            return false;
        } else if (query.type === "and") {
            return query.children.every(child => evaluateQuery(child, sample));
        } else if (query.type === "or") {
            return query.children.some(child => evaluateQuery(child, sample));
        } else if (query.type === "xor") {
            let matches = query.children.filter(child => evaluateQuery(child, sample));
            return matches.length === 1;
        } else if (query.type === "not") {
            return !query.children.every(child => evaluateQuery(child, sample));
        }
        return false;
    };
    
    // initialize targets and cells list
    let listingDiv = document.querySelector("#listing");
    listingDiv.textContent = "";

    // Parse the query string
    queryString = queryString.trim();
    let results = database;
    if (queryString.length !== 0) {
        let queries = parseQuery(queryString);
        // Filter database
        results = database.filter(sample => evaluateQuery(queries, sample));
    } else {
        results = Array.from(database);
    }

    // Sort results
    let sortFn = (a, b) => {
        if (a === "?" || b === "?") {
            if (a === "?" && b === "?") return 0;
            if (a === "?") return 1;
            return -1;
        }
        return (STATE.sort.reverse ? -1 : 1) * a.localeCompare(b);
        if (a < b) return STATE.sort.reverse ? 1 : -1;
        if (a > b) return STATE.sort.reverse ? -1 : 1;
        return 0;
    };
    if (STATE.sort.by != null) {
        results.sort((a, b) => sortFn(a[STATE.sort.by][0], b[STATE.sort.by][0]));
    }

    // Update listing controls
    let uniques = {};
    let listingControlDiv = listingDiv.appendChild(document.createElement("div"));
    for (let [label, value, entryIndex] of [["GSEs", "gse", 0], ["Targets", "targets", 5], ["Cells", "cells", 4]]) {
        uniques[value] = new Map();
        for (let entry of results) {
            uniques[value].set(entry[entryIndex][0], entry);
        }
        let div = listingControlDiv.appendChild(document.createElement("div"));
        div.textContent = `${label} (${formatNumber(uniques[value].size, {thousands: ","})})`;
        div.classList.add("symbol-left", "symbol-colored");
        div.dataset.symbol = (STATE.display.listing === value) ? "radio_button_checked" : "radio_button_unchecked";
        div.onclick = async () => {
            STATE.display.listing = value;
            await searchSamples();
        };
    }
    let listingListDiv = listingDiv.appendChild(document.createElement("div"));

    // Update listing list
    if (STATE.display.listing === "targets") {
        uniques["targets"] = Array.from(uniques["targets"].values());
        for (let entry of uniques["targets"].slice(0, STATE.display.listingCount)) {
            let div = listingListDiv.appendChild(document.createElement("div"));
            let entryNameDiv = div.appendChild(document.createElement("div"));
            let entrySummaryDiv = div.appendChild(document.createElement("div"));

            let minimalName = getEntryTargetName(entry[5][1]);
            let summary = targetsSummaries.get(minimalName) || {};

            let entryLabelDiv = entryNameDiv.appendChild(document.createElement("span"));
            entryLabelDiv.textContent = summary.name || entry[5][0];
            let entryAliasesDiv = entryNameDiv.appendChild(document.createElement("span"));
            entryAliasesDiv.textContent = [summary.full_name || "", ...(summary.aliases || [])]
                .filter(x => x.length > 0)
                .map(alias => alias.trim())
                .join(", ");

            if (STATE.display.summaries) {
                let classDiv = entrySummaryDiv.appendChild(document.createElement("span"));
                classDiv.textContent = (summary.classification || "Unclassified") + ".";
                classDiv.style.fontWeight = "bold";
                entrySummaryDiv.appendChild(document.createElement("span")).textContent = " ";
                let descriptionDiv = entrySummaryDiv.appendChild(document.createElement("span"));
                descriptionDiv.textContent = summary.description || "No summary available.";
                descriptionDiv.appendChild(document.createElement("span")).textContent = " ";
                
                let entryExpandDiv = entrySummaryDiv.appendChild(document.createElement("a"));
                entryExpandDiv.onclick = () => showTargetSummary({genome, key: summary.name});
                entryExpandDiv.textContent = "Expand";
                entryExpandDiv.classList.add("desaturated-color");
            }
        }
    } else if (STATE.display.listing === "cells") {
        uniques["cells"] = Array.from(uniques["cells"].values());
        for (let entry of uniques["cells"].slice(0, STATE.display.listingCount)) {
            let div = listingListDiv.appendChild(document.createElement("div"));
            let entryNameDiv = div.appendChild(document.createElement("div"));
            let entrySummaryDiv = div.appendChild(document.createElement("div"));

            let minimalName = getEntryTargetName(entry[4][1]);
            let summary = cellsSummaries.get(minimalName) || {};

            let entryLabelDiv = entryNameDiv.appendChild(document.createElement("span"));
            entryLabelDiv.textContent = entry[4][0].match(/^([^(]*).*$/)[1];
            let entryTissueDiv = entryNameDiv.appendChild(document.createElement("span"));
            entryTissueDiv.textContent = (entry[4][0].match(/^[^(]*\(([^(]*)\)$/) || ["", ""])[1];

            if (STATE.display.summaries) {
                let classDiv = entrySummaryDiv.appendChild(document.createElement("span"));
                let classContent = [
                    summary.classification || "Unclassified",
                    summary.tissue || "",
                    summary.organ || "",
                ]
                classContent = classContent.filter(x => x.length > 0).join(" | ");
                classDiv.textContent = classContent + ".";
                classDiv.style.fontWeight = "bold";
                entrySummaryDiv.appendChild(document.createElement("span")).textContent = " ";
                let descriptionDiv = entrySummaryDiv.appendChild(document.createElement("span"));
                descriptionDiv.textContent = summary.description || "No summary available.";
                descriptionDiv.appendChild(document.createElement("span")).textContent = " ";
                
                let entryExpandDiv = entrySummaryDiv.appendChild(document.createElement("a"));
                entryExpandDiv.onclick = () => showCellSummary({genome, key: entry[4][0].match(/^([^(]*).*$/)[1].trim()});
                entryExpandDiv.textContent = "Expand";
                entryExpandDiv.classList.add("desaturated-color");
            }
        }
        
    } else if (STATE.display.listing === "gse") {
        let resultsByGse = new Map();
        for (let entry of results) {
            let gse = entry[0][0];
            if (!uniques["gse"].has(gse)) break;
            if (!resultsByGse.has(gse)) resultsByGse.set(gse, []);
            resultsByGse.get(gse).push(entry);
            if (resultsByGse.size >= STATE.display.listingCount) break;
        }
        uniques["gse"] = Array.from(uniques["gse"].values());
        for (let [gse, entries] of resultsByGse) {
            let div = listingListDiv.appendChild(document.createElement("div"));
            let gseDiv = div.appendChild(document.createElement("div"));
            let gseLabelDiv = gseDiv.appendChild(document.createElement("span"));
            gseLabelDiv.textContent = gse;
            let gseCountLinkDiv = gseDiv.appendChild(document.createElement("span"));
            let gseCountDiv = gseCountLinkDiv.appendChild(document.createElement("span"));
            gseCountDiv.textContent = `${formatNumber(entries.length, {thousands: ","})} samples, `;
            let gseLinkDiv = gseCountLinkDiv.appendChild(document.createElement("a"));
            gseLinkDiv.textContent = "go to GEO";
            gseLinkDiv.href = `https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=${gse}`;
            gseLinkDiv.target = "_blank";
            gseLinkDiv.rel = "noopener noreferrer";

            if (STATE.display.summaries) {
                let detailsDiv = div.appendChild(document.createElement("div"));
                let targetsSet = new Map();
                let cellsSet = new Map();
                for (let entry of entries) {
                    targetsSet.set(entry[5][0].match(/^([^(]*).*$/)[1].trim(), null);
                    cellsSet.set(entry[4][0].match(/^([^(]*).*$/)[1].trim(), null);
                }
                let targetsDiv = detailsDiv.appendChild(document.createElement("div"));
                targetsDiv.textContent = `${targetsSet.size} targets: ${Array.from(targetsSet.keys()).join(", ")}`;
                let cellsDiv = detailsDiv.appendChild(document.createElement("div"));
                cellsDiv.textContent = `${cellsSet.size} cells: ${Array.from(cellsSet.keys()).join(", ")}`;
            }
        }

    }
    if (uniques[STATE.display.listing].length > STATE.display.listingCount) {
        let div = listingListDiv.appendChild(document.createElement("div"));
        let moreCount = formatNumber(uniques[STATE.display.listing].length - STATE.display.listingCount, {thousands: ","})
        div.textContent = `[ + ${moreCount} more ]`;
    }

    await updateSamplesList({genome, database: results});
}


function makeKeyValueDiv(parent, {fieldClasses=[]}={}) {
    let fieldDiv = parent.appendChild(document.createElement("div"));
    for (let fieldClass of fieldClasses) {
        fieldDiv.classList.add(fieldClass);
    }
    fieldDiv.classList.add("key-value-pair");
    let keyDiv = fieldDiv.appendChild(document.createElement("div"));
    let valueDiv = fieldDiv.appendChild(document.createElement("div"));
    return [keyDiv, valueDiv];
}
async function toggleMoreInfo(moreInfoHeaderDiv, moreInfoDiv, div, openFunction) {
    let divOpened = div.dataset.opened === "true";
    moreInfoDiv.textContent = "";
    moreInfoHeaderDiv.querySelectorAll("a.show-hide").forEach(a => {
        a.textContent = "Show";
        a.dataset.opened = "false";
    });
    if (!divOpened) {
        div.textContent = "Hide";
        div.dataset.opened = "true";
        await openFunction();
    }
}

function initFullInfo({type, accession, isNavigation=false}={}) {
    if (!isNavigation) {
        let last = STATE.fullInfo.back[STATE.fullInfo.back.length - 1];
        let isDuplicate = last && 
            last.type === type && 
            last.accession.genome === accession.genome && 
            last.accession.key === accession.key;
        if (!isDuplicate) {
            STATE.fullInfo.back.push({type, accession});
            STATE.fullInfo.forward = [];
        }
    }
    if (STATE.fullInfo.back.length > 100) STATE.fullInfo.back = STATE.fullInfo.back.slice(50);
    if (STATE.fullInfo.forward.length > 100) STATE.fullInfo.forward = STATE.fullInfo.forward.slice(50);
    let mainDiv = document.querySelector("#full-sample");
    mainDiv.textContent = "";
    let controlDiv = mainDiv.appendChild(document.createElement("div"));
    controlDiv.classList.add("control");
    let sectionsDiv = mainDiv.appendChild(document.createElement("div"));
    sectionsDiv.classList.add("sections");
    
    if (STATE.fullInfo.back.length > 1) {
        let backDiv = controlDiv.appendChild(document.createElement("a"));
        let previous = STATE.fullInfo.back[STATE.fullInfo.back.length - 2];
        backDiv.textContent = previous.accession.key;
        backDiv.classList.add("symbol-left", "symbol-colored", "no-underline", "only-colored-on-hover");
        backDiv.dataset.symbol = "keyboard_arrow_left";
        backDiv.onclick = async () => {
            let current = STATE.fullInfo.back.pop();
            if (!current) return;
            STATE.fullInfo.forward.push(current);
            let previous = STATE.fullInfo.back[STATE.fullInfo.back.length - 1];
            if (!previous) return;
            if (previous.type === "sample") {
                await showFullSample({...previous.accession, isNavigation: true});
            } else if (previous.type === "target") {
                await showTargetSummary({...previous.accession, isNavigation: true});
            } else if (previous.type === "cell") {
                await showCellSummary({...previous.accession, isNavigation: true});
            }
        };
    }
    
    let currentDiv = controlDiv.appendChild(document.createElement("span"));
    currentDiv.textContent = accession.key;
    currentDiv.style.fontWeight = "bold";

    if (STATE.fullInfo.forward.length > 0) {
        let forwardDiv = controlDiv.appendChild(document.createElement("a"));
        let next = STATE.fullInfo.forward[STATE.fullInfo.forward.length - 1];
        forwardDiv.textContent = next.accession.key;
        forwardDiv.classList.add("symbol-right", "symbol-colored", "no-underline", "only-colored-on-hover");
        forwardDiv.dataset.symbol = "keyboard_arrow_right";
        forwardDiv.onclick = async () => {
            let next = STATE.fullInfo.forward.pop();
            if (!next) return;
            STATE.fullInfo.back.push(next);
            if (next.type === "sample") {
                await showFullSample({...next.accession, isNavigation: true});
            } else if (next.type === "target") {
                await showTargetSummary({...next.accession, isNavigation: true});
            }
        };
    }
    return [mainDiv, controlDiv, sectionsDiv];
}

async function showTargetSummary({genome, key, isNavigation=false}={}) {
    let minimalName = getEntryTargetName(key);
    let targetsSummaries = await getTargetsSummaries({genome});
    let summary = targetsSummaries.get(minimalName) || {};
    let urlSearchTerm = encodeURIComponent(summary.name || "");

    let [,, div] = initFullInfo({type: "target", accession: {genome, key}, isNavigation});
    let fieldsDiv = div.appendChild(document.createElement("div"));
    fieldsDiv.classList.add("section");
    let longDescriptionDiv = div.appendChild(document.createElement("div"));
    longDescriptionDiv.classList.add("section");
    let linksDiv = div.appendChild(document.createElement("div"));
    linksDiv.classList.add("section");
    let moreInfoDiv = div.appendChild(document.createElement("div"));
    moreInfoDiv.classList.add("section");

    let [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Name";
    valueDiv.textContent = `${summary.name || ""} | ${summary.full_name || ""}`;
    if ((summary.aliases || []).length > 0) {
        [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
        keyDiv.textContent = "Aliases";
        valueDiv.textContent = summary.aliases.join(", ");
    }
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Classification";
    valueDiv.textContent = summary.classification || "Unclassified";
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Description";
    valueDiv.textContent = summary.description || "No description available.";

    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "Links";
    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "Go To";
    let ncbiDiv = valueDiv.appendChild(document.createElement("a"));
    ncbiDiv.href = `https://www.ncbi.nlm.nih.gov/gene/?term=${urlSearchTerm}`;
    ncbiDiv.textContent = "NCBI";
    ncbiDiv.target = "_blank";
    let geneCardsDiv = valueDiv.appendChild(document.createElement("a"));
    geneCardsDiv.href = `https://www.genecards.org/Search/Keyword?queryString=${urlSearchTerm}`;
    geneCardsDiv.textContent = "GeneCards";
    geneCardsDiv.target = "_blank";

    [keyDiv, valueDiv] = makeKeyValueDiv(longDescriptionDiv);
    let md = window.markdownit();
    let result = md.render(summary.long_description || "No long description available.");
    valueDiv.innerHTML = result;
    valueDiv.classList.add("markdown");

    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "NCBI Gene Info";
    {
        let showInfoDiv = valueDiv.appendChild(document.createElement("a"));
        showInfoDiv.textContent = "Show";
        showInfoDiv.classList.add("show-hide");
        let showInfo = async () => {
            let term = key.match(/^([^(]*).*$/)[1];
            let taxon = (await getAvailableGenomes())[genome].taxon_id;
            let url = `https://api.ncbi.nlm.nih.gov/datasets/v2/gene/symbol/${term}/taxon/${taxon}/dataset_report`;
            let responseData;
            try {
                let response = await fetchUrl(url);
                responseData = await response.json();
                if (!(responseData.reports || [])) throw new Error("No reports");
                responseData = responseData.reports[0].gene;
            } catch (e) {
                let [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
                itemKeyDiv.textContent = "Error";
                itemValueDiv.textContent = `No NCBI gene info ${term}`;
                return;
            }
            let [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
            itemKeyDiv.textContent = "Gene ID";
            itemValueDiv.textContent = responseData.gene_id;
            [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
            itemKeyDiv.textContent = "Symbol";
            itemValueDiv.textContent = responseData.symbol;
            [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
            itemKeyDiv.textContent = "Synonyms";
            itemValueDiv.textContent = responseData.synonyms.join(", ");
            [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
            itemKeyDiv.textContent = "Description";
            itemValueDiv.textContent = responseData.description;
            [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
            itemKeyDiv.textContent = "Summary";
            itemValueDiv.textContent = responseData.summary.map(x => x.description).join(" | ");
            [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
            itemKeyDiv.textContent = "Molecular functions";
            itemValueDiv.textContent = uniquesInArray(responseData.gene_ontology.molecular_functions.map(x => `${x.qualifier} ${x.name}`)).join(", ");
            [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
            itemKeyDiv.textContent = "Biological processes";
            itemValueDiv.textContent = uniquesInArray(responseData.gene_ontology.biological_processes.map(x => `${x.qualifier} ${x.name}`)).join(", ");
            [itemKeyDiv, itemValueDiv] = makeKeyValueDiv(moreInfoDiv);
            itemKeyDiv.textContent = "Cellular components";
            itemValueDiv.textContent = uniquesInArray(responseData.gene_ontology.cellular_components.map(x => `${x.qualifier} ${x.name}`)).join(", ");
        }
        showInfoDiv.onclick = () => toggleMoreInfo(linksDiv, moreInfoDiv, showInfoDiv, showInfo);
    }

}


async function showCellSummary({genome, key, isNavigation=false}={}) {
    let minimalName = getEntryTargetName(key);
    let cellsSummaries = await getCellsSummaries({genome});
    let summary = cellsSummaries.get(minimalName) || {};

    let [,, div] = initFullInfo({type: "cell", accession: {genome, key}, isNavigation});
    let fieldsDiv = div.appendChild(document.createElement("div"));
    fieldsDiv.classList.add("section");
    let longDescriptionDiv = div.appendChild(document.createElement("div"));
    longDescriptionDiv.classList.add("section");

    let [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Name";
    valueDiv.textContent = summary.name || "";
    if ((summary.aliases || []).length > 0) {
        [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
        keyDiv.textContent = "Aliases";
        valueDiv.textContent = summary.aliases.join(", ");
    }
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Classification";
    valueDiv.textContent = summary.classification || "Unclassified";
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Tissue";
    valueDiv.textContent = summary.tissue || "Unknown";
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Organ";
    valueDiv.textContent = summary.organ || "Unknown";
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Description";
    valueDiv.textContent = summary.description || "No description available.";

    [keyDiv, valueDiv] = makeKeyValueDiv(longDescriptionDiv);
    let md = window.markdownit();
    let result = md.render(summary.long_description || "No long description available.");
    valueDiv.innerHTML = result;
    valueDiv.classList.add("markdown");
}


async function showFullSample({genome, key, isNavigation=false}={}) {
    let srx = key;
    let data = (await getDatabase({genome}));
    data = data.filter(x => x[2][0] === srx);
    if (data.length !== 1) throw new Error(`${srx} found 0 or multiple times in full database.`);
    data = data[0].map(x => x[0]);
    data[8] = data[8] === "?" ? [] : data[8].split(",");
    data[9] = data[9].split(";").map(x => x.split("="));

    let [,, div] = initFullInfo({type: "sample", accession: {genome, key}, isNavigation});
    let fieldsDiv = div.appendChild(document.createElement("div"));
    fieldsDiv.classList.add("section", "fields");
    let attributesDiv = div.appendChild(document.createElement("div"));
    attributesDiv.classList.add("section", "attributes");
    let logsDiv = div.appendChild(document.createElement("div"));
    logsDiv.classList.add("section", "logs");
    let summaryDiv = div.appendChild(document.createElement("div"));
    summaryDiv.classList.add("section", "summary");
    let linksDiv = div.appendChild(document.createElement("div"));
    linksDiv.classList.add("section", "links");
    let moreInfoDiv = div.appendChild(document.createElement("div"));
    moreInfoDiv.classList.add("section", "more-info");

    let [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "GSE";
    valueDiv.textContent = data[0];
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "GSM";
    valueDiv.textContent = data[1];
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "SRX";
    valueDiv.textContent = data[2];
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Target";
    valueDiv.textContent = data[5];
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Genome";
    valueDiv.textContent = data[3];
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Cell";
    valueDiv.textContent = data[4];
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Date";
    valueDiv.textContent = data[6];
    [keyDiv, valueDiv] = makeKeyValueDiv(fieldsDiv);
    keyDiv.textContent = "Title";
    valueDiv.textContent = data[7];

    [keyDiv, valueDiv] = makeKeyValueDiv(attributesDiv);
    keyDiv.textContent = "Attributes";
    for (let [key, value] of data[9]) {
        [keyDiv, valueDiv] = makeKeyValueDiv(attributesDiv);
        keyDiv.textContent = key
            .replace(/_/g, " ")
            .replace(/\w\S*/g, w => w.charAt(0).toUpperCase() + w.slice(1));
        valueDiv.textContent = value;
    }

    [keyDiv, valueDiv] = makeKeyValueDiv(logsDiv);
    keyDiv.textContent = "Processing Logs";
    [keyDiv, valueDiv] = makeKeyValueDiv(logsDiv);
    keyDiv.textContent = "Sequencing";
    valueDiv.textContent = `${formatNumber(data[8][0], {thousands: ","})} reads`;
    if (data[5].toLowerCase() === "bisulfite-seq") {
        [keyDiv, valueDiv] = makeKeyValueDiv(logsDiv);
        keyDiv.textContent = "Mapping";
        valueDiv.textContent = `${formatNumber(data[8][1], {thousands: ","})} %`;
        [keyDiv, valueDiv] = makeKeyValueDiv(logsDiv);
        keyDiv.textContent = "Coverage";
        valueDiv.textContent = `${formatNumber(data[8][2], {thousands: ","})} Ã`;
        [keyDiv, valueDiv] = makeKeyValueDiv(logsDiv);
        keyDiv.textContent = "Hyper MR";;
        valueDiv.textContent = `${formatNumber(data[8][3], {thousands: ","})} %`;
    } else {
        [keyDiv, valueDiv] = makeKeyValueDiv(logsDiv);
        keyDiv.textContent = "Mapping";
        valueDiv.textContent = `${formatNumber(data[8][1], {thousands: ","})} %`;
        valueDiv.textContent += ` with ${formatNumber(data[8][2], {thousands: ","})} % duplicates`;
        [keyDiv, valueDiv] = makeKeyValueDiv(logsDiv);
        keyDiv.textContent = "Peaks";
        valueDiv.textContent = `${formatNumber(data[8][3], {thousands: ","})} below 1e-5`;
    }

    let minimalName = getEntryTargetName(data[5]);
    let targetsSummaries = await getTargetsSummaries({genome});
    let targetSummary = targetsSummaries.get(minimalName) || {};
    [keyDiv, valueDiv] = makeKeyValueDiv(summaryDiv);
    keyDiv.textContent = "Target Summary";
    [keyDiv, valueDiv] = makeKeyValueDiv(summaryDiv);
    keyDiv.textContent = "Name";
    valueDiv.textContent = `${targetSummary.name || ""} | ${targetSummary.full_name || ""}`;
    if ((targetSummary.aliases || []).length > 0) {
        [keyDiv, valueDiv] = makeKeyValueDiv(summaryDiv);
        keyDiv.textContent = "Aliases";
        valueDiv.textContent = (targetSummary.aliases || []).join(", ");
    }
    [keyDiv, valueDiv] = makeKeyValueDiv(summaryDiv);
    keyDiv.textContent = "Classification";
    valueDiv.textContent = targetSummary.classification || "Unclassified";
    [keyDiv, valueDiv] = makeKeyValueDiv(summaryDiv);
    keyDiv.textContent = "Description";
    let targetDescriptionDiv = valueDiv.appendChild(document.createElement("span"));
    let targetDescriptionTextDiv = targetDescriptionDiv.appendChild(document.createElement("span"));
    targetDescriptionTextDiv.textContent = (targetSummary.description || "No description available.") + " ";
    let targetDescriptionExpandDiv = targetDescriptionDiv.appendChild(document.createElement("a"));
    targetDescriptionExpandDiv.textContent = "Expand";
    targetDescriptionExpandDiv.onclick = () => showTargetSummary({genome, key: targetSummary.name});

    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "Links";
    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "Source";
    let sourceDiv = valueDiv;
    let chipAtlasDiv = sourceDiv.appendChild(document.createElement("a"));
    chipAtlasDiv.href = `https://chip-atlas.org/view?id=${srx}`;
    chipAtlasDiv.textContent = "ChIP-Atlas";
    chipAtlasDiv.target = "_blank";
    if (data[1] !== "?") {
        let geoDiv = sourceDiv.appendChild(document.createElement("a"));
        geoDiv.href = `https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=${data[1]}`;
        geoDiv.textContent = "GEO";
        geoDiv.target = "_blank";
    }
    let sraDiv = sourceDiv.appendChild(document.createElement("a"));
    sraDiv.href = `https://www.ncbi.nlm.nih.gov/sra/?term=${srx}`;
    sraDiv.textContent = "SRA";
    sraDiv.target = "_blank";
    let enaDiv = sourceDiv.appendChild(document.createElement("a"));
    enaDiv.href = `https://www.ebi.ac.uk/ena/browser/view/${srx}`;
    enaDiv.textContent = "ENA";
    enaDiv.target = "_blank";

    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "Fastq";
    let fastqDiv = valueDiv;
    setTimeout(async () => {
        let url = `https://www.ebi.ac.uk/ena/portal/api/filereport?accession=${srx}&result=read_run&fields=run_accession,fastq_ftp,fastq_bytes`;
        let response = await fetchUrl(url);
        response = await response.text();
        let lines = response.trim().split("\n");
        if (lines.length < 2) return;
        for (let line of lines.slice(1)) {
            let paths = line.split("\t")[1].split(";");
            let sizes = line.split("\t")[2].split(";");
            if (paths.length !== sizes.length) continue;
            if ((paths.length !== 1 && paths.length !== 2) || paths[0].length === 0) continue;
            for (let i = 0; i < paths.length; i++) {
                let link = fastqDiv.appendChild(document.createElement("a"));
                link.href = `https://${paths[i]}`;
                link.textContent = paths.length === 1 ? "Single-end" : `R${i + 1}`;
                let size = formatNumber(Number(sizes[i]), {notation: "si", precision: 0.01, thousands: ","});
                link.textContent += ` (${size}B)`;
                link.classList.add("appear-smoothly");
            }
        }
    }, 0);
    
    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "Processed";
    let processedDiv = valueDiv;
    let peaksDiv = processedDiv.appendChild(document.createElement("a"));
    peaksDiv.href = `https://chip-atlas.dbcls.jp/data/${data[3]}/eachData/bed05/${srx}.05.bed`;
    peaksDiv.textContent = "Peaks";
    let bigwigDiv = processedDiv.appendChild(document.createElement("a"));
    let bigwigNameDiv = bigwigDiv.appendChild(document.createElement("span"));
    let bigwigSizeDiv = bigwigDiv.appendChild(document.createElement("span"));
    bigwigDiv.href = `https://chip-atlas.dbcls.jp/data/${data[3]}/eachData/bw/${srx}.bw`;
    bigwigNameDiv.textContent = "Bigwig";
    setTimeout(async () => {
        let response = await fetchUrl(bigwigDiv.href, {method: "HEAD"});
        let size = formatNumber(Number(response.headers.get("Content-Length")), {notation: "si", precision: 0.01, thousands: ","});
        bigwigSizeDiv.textContent = ` (${size}B)`;
        bigwigSizeDiv.classList.add("appear-smoothly");
    }, 0);

    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "GeneCards";
    let genecardsDiv = valueDiv.appendChild(document.createElement("a"));
    let genecardsTerm  = data[5].match(/^([^(]*).*$/)[1];
    genecardsDiv.href = `https://www.genecards.org/Search/Keyword?queryString=${encodeURIComponent(genecardsTerm)}`;
    genecardsDiv.textContent = genecardsTerm;
    genecardsDiv.target = "_blank";
    [keyDiv, valueDiv] = makeKeyValueDiv(linksDiv);
    keyDiv.textContent = "GEO Submission";
    if (data[1] === "?") {
        valueDiv.textContent = "Not available";
    } else {
        let showInfoDiv = valueDiv.appendChild(document.createElement("a"));
        showInfoDiv.textContent = "Show";
        showInfoDiv.classList.add("show-hide");
        let showInfo = async () => {
            let gsmInfo = await getGSMInfo({gsm: data[1]});
            for (let [infoKey, infoValue] of gsmInfo) {
                let [keyDiv, valueDiv] = makeKeyValueDiv(moreInfoDiv);
                infoKey = infoKey.replace(/_/g, " ");
                if (infoKey.startsWith("sample") && infoKey !== "sample") infoKey = infoKey.slice(6).trim();
                infoKey = infoKey.replace(/\w\S*/g, w => w.charAt(0).toUpperCase() + w.slice(1));
                keyDiv.textContent = infoKey;
                infoValue = infoValue.replace(/\s+/g, " ").trim();
                valueDiv.textContent = infoValue;
            }
        }
        showInfoDiv.onclick = () => toggleMoreInfo(linksDiv, moreInfoDiv, showInfoDiv, showInfo);
    }

}



async function getGSMInfo({gsm}={}) {
    let url = `https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=${gsm}&targ=self&form=text`;
    let response = await fetchUrl(url);
    let data = await response.text();
    data = data.trim().split("\n")
        .map(line => line.slice(1).split("=").map(x => x.trim()))
        .map(pair => [pair[0].toLowerCase(), pair[1] || ""]);
    return data;
}


function uniquesInArray(array) {
    let seen = new Set();
    let uniqueArray = [];
    for (let item of array) {
        if (!seen.has(item)) {
            seen.add(item);
            uniqueArray.push(item);
        }
    }
    return uniqueArray;
}



async function main() {

    for (let div of document.querySelectorAll("#search-fields-control > div:not(:nth-child(1))")) {
        div.onclick = async () => {
            if (div.dataset.checked === "true") {
                div.dataset.checked = "false";
            } else {
                div.dataset.checked = "true";
            }
            await searchSamples();
        };
    }

    await getAvailableGenomes();
    await searchSamples();

}

main();




        </script>
    </body>
</html>
